{"version":3,"sources":["transformDirectory.mjs"],"sourcesContent":["import path from 'path';\nimport Iterator from 'fs-iterator';\nimport getTS from 'get-tsconfig-compat';\n\nimport createMatcher from './createMatcher.mjs';\nimport transformFile from './transformFile.mjs';\n\nfunction transformDirectoryCallback(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (typeof src !== 'string') throw new Error('transformDirectory: unexpected source');\n  if (typeof dest !== 'string') throw new Error('transformDirectory: unexpected destination directory');\n  if (typeof type !== 'string') throw new Error('transformDirectory: unexpected type');\n\n  const cwd = options.cwd || process.cwd();\n  const config = options.confg ? options.confg : getTS.getTsconfig(path.resolve(cwd, 'tsconfig.json'));\n  const matcher = createMatcher(config);\n\n  options = { ...options, config };\n  const iterator = new Iterator(src);\n  iterator.forEach(\n    (entry, cb) => {\n      if (!entry.stats.isFile()) return cb();\n      if (!matcher(entry.fullPath)) return cb();\n      transformFile(entry.fullPath, path.dirname(path.join(dest, entry.path)), type, options, cb);\n    },\n    { callbacks: true, concurrency: options.concurrency || 1024 },\n    callback\n  );\n}\n\n/**\n * @param {string} src The source directory to traverse.\n * @param {string} dest The output directory to write files to.\n * @param {string} type The type of transform ('esm' or 'cjs').\n * @param {{sourceMaps: boolean}} options Options to pass to swc.\n * @param {(err?: Error) =>} [callback] Optional callback. Uses promise if callback not provided.\n * @returns {void | Promise<any>} Optional promise if callback not provided.\n */\nexport default function transformDirectory(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n\n  if (typeof callback === 'function') return transformDirectoryCallback(src, dest, type, options, callback);\n  return new Promise((resolve, reject) => {\n    transformDirectoryCallback(src, dest, type, options, function compileCallback(err, result) {\n      err ? reject(err) : resolve(result);\n    });\n  });\n}\n"],"names":["transformDirectory","transformDirectoryCallback","src","dest","type","options","callback","Error","cwd","process","config","confg","getTS","getTsconfig","path","resolve","matcher","createMatcher","iterator","Iterator","forEach","entry","cb","stats","isFile","fullPath","transformFile","dirname","join","callbacks","concurrency","Promise","reject","compileCallback","err","result"],"mappings":";;;;+BAiCA;;;;;;;CAOC,GACD;;;eAAwBA;;;2DAzCP;iEACI;wEACH;oEAEQ;oEACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE1B,SAASC,2BAA2BC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IACpE,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU,CAAC;IACb;IACA,IAAI,OAAOH,QAAQ,UAAU,MAAM,IAAIK,MAAM;IAC7C,IAAI,OAAOJ,SAAS,UAAU,MAAM,IAAII,MAAM;IAC9C,IAAI,OAAOH,SAAS,UAAU,MAAM,IAAIG,MAAM;IAE9C,IAAMC,MAAMH,QAAQG,GAAG,IAAIC,QAAQD,GAAG;IACtC,IAAME,SAASL,QAAQM,KAAK,GAAGN,QAAQM,KAAK,GAAGC,0BAAK,CAACC,WAAW,CAACC,aAAI,CAACC,OAAO,CAACP,KAAK;IACnF,IAAMQ,UAAUC,IAAAA,sBAAa,EAACP;IAE9BL,UAAU,wCAAKA;QAASK,QAAAA;;IACxB,IAAMQ,WAAW,IAAIC,mBAAQ,CAACjB;IAC9BgB,SAASE,OAAO,CACd,SAACC,OAAOC;QACN,IAAI,CAACD,MAAME,KAAK,CAACC,MAAM,IAAI,OAAOF;QAClC,IAAI,CAACN,QAAQK,MAAMI,QAAQ,GAAG,OAAOH;QACrCI,IAAAA,sBAAa,EAACL,MAAMI,QAAQ,EAAEX,aAAI,CAACa,OAAO,CAACb,aAAI,CAACc,IAAI,CAACzB,MAAMkB,MAAMP,IAAI,IAAIV,MAAMC,SAASiB;IAC1F,GACA;QAAEO,WAAW;QAAMC,aAAazB,QAAQyB,WAAW,IAAI;IAAK,GAC5DxB;AAEJ;AAUe,SAASN,mBAAmBE,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IAC3E,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU;IACZ;IACAA,UAAUA,WAAW,CAAC;IAEtB,IAAI,OAAOC,aAAa,YAAY,OAAOL,2BAA2BC,KAAKC,MAAMC,MAAMC,SAASC;IAChG,OAAO,IAAIyB,QAAQ,SAAChB,SAASiB;QAC3B/B,2BAA2BC,KAAKC,MAAMC,MAAMC,SAAS,SAAS4B,gBAAgBC,GAAG,EAAEC,MAAM;YACvFD,MAAMF,OAAOE,OAAOnB,QAAQoB;QAC9B;IACF;AACF"}