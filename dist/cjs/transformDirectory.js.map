{"version":3,"sources":["transformDirectory.mjs"],"sourcesContent":["import path from 'path';\nimport Iterator from 'fs-iterator';\nimport getTS from 'get-tsconfig-compat';\n\nimport createMatcher from './createMatcher.mjs';\nimport transformFile from './transformFile.mjs';\n\nfunction transformDirectoryCallback(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n\n  if (typeof src !== 'string') throw new Error('transformDirectory: unexpected source');\n  if (typeof dest !== 'string') throw new Error('transformDirectory: unexpected destination directory');\n  if (typeof type !== 'string') throw new Error('transformDirectory: unexpected type');\n\n  const config = options.confg ? options.confg : getTS.getTsconfig(src);\n  const matcher = createMatcher(config);\n\n  options = { ...options, config };\n  const iterator = new Iterator(src);\n  iterator.forEach(\n    (entry, cb) => {\n      if (!entry.stats.isFile()) return cb();\n      if (!matcher(entry.fullPath)) return cb();\n      transformFile(entry.fullPath, path.dirname(path.join(dest, entry.path)), type, options, cb);\n    },\n    { callbacks: true, concurrency: options.concurrency || 1024 },\n    callback\n  );\n}\n\n/**\n * @param {string} src The source directory to traverse.\n * @param {string} dest The output directory to write files to.\n * @param {string} type The type of transform ('esm' or 'cjs').\n * @param {{sourceMaps: boolean}} options Options to pass to swc.\n * @param {(err?: Error) =>} [callback] Optional callback. Uses promise if callback not provided.\n * @returns {void | Promise<any>} Optional promise if callback not provided.\n */\nexport default function transformDirectory(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n\n  if (typeof callback === 'function') return transformDirectoryCallback(src, dest, type, options, callback);\n  return new Promise((resolve, reject) => {\n    transformDirectoryCallback(src, dest, type, options, function compileCallback(err, result) {\n      err ? reject(err) : resolve(result);\n    });\n  });\n}\n"],"names":["transformDirectory","transformDirectoryCallback","src","dest","type","options","callback","Error","config","confg","getTS","getTsconfig","matcher","createMatcher","iterator","Iterator","forEach","entry","cb","stats","isFile","fullPath","transformFile","path","dirname","join","callbacks","concurrency","Promise","resolve","reject","compileCallback","err","result"],"mappings":";;;;+BAkCA;;;;;;;CAOC,GACD;;;eAAwBA;;;2DA1CP;iEACI;wEACH;oEAEQ;oEACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAE1B,SAASC,2BAA2BC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IACpE,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU,CAAC;IACb;IACAA,UAAUA,WAAW,CAAC;IAEtB,IAAI,OAAOH,QAAQ,UAAU,MAAM,IAAIK,MAAM;IAC7C,IAAI,OAAOJ,SAAS,UAAU,MAAM,IAAII,MAAM;IAC9C,IAAI,OAAOH,SAAS,UAAU,MAAM,IAAIG,MAAM;IAE9C,IAAMC,SAASH,QAAQI,KAAK,GAAGJ,QAAQI,KAAK,GAAGC,0BAAK,CAACC,WAAW,CAACT;IACjE,IAAMU,UAAUC,IAAAA,sBAAa,EAACL;IAE9BH,UAAU,wCAAKA;QAASG,QAAAA;;IACxB,IAAMM,WAAW,IAAIC,mBAAQ,CAACb;IAC9BY,SAASE,OAAO,CACd,SAACC,OAAOC;QACN,IAAI,CAACD,MAAME,KAAK,CAACC,MAAM,IAAI,OAAOF;QAClC,IAAI,CAACN,QAAQK,MAAMI,QAAQ,GAAG,OAAOH;QACrCI,IAAAA,sBAAa,EAACL,MAAMI,QAAQ,EAAEE,aAAI,CAACC,OAAO,CAACD,aAAI,CAACE,IAAI,CAACtB,MAAMc,MAAMM,IAAI,IAAInB,MAAMC,SAASa;IAC1F,GACA;QAAEQ,WAAW;QAAMC,aAAatB,QAAQsB,WAAW,IAAI;IAAK,GAC5DrB;AAEJ;AAUe,SAASN,mBAAmBE,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IAC3E,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU;IACZ;IACAA,UAAUA,WAAW,CAAC;IAEtB,IAAI,OAAOC,aAAa,YAAY,OAAOL,2BAA2BC,KAAKC,MAAMC,MAAMC,SAASC;IAChG,OAAO,IAAIsB,QAAQ,SAACC,SAASC;QAC3B7B,2BAA2BC,KAAKC,MAAMC,MAAMC,SAAS,SAAS0B,gBAAgBC,GAAG,EAAEC,MAAM;YACvFD,MAAMF,OAAOE,OAAOH,QAAQI;QAC9B;IACF;AACF"}