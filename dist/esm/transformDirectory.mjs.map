{"version":3,"sources":["transformDirectory.mjs"],"sourcesContent":["import path from 'path';\nimport Iterator from 'fs-iterator';\nimport getTS from 'get-tsconfig-compat';\n\nimport createMatcher from './createMatcher.mjs';\nimport transformFile from './transformFile.mjs';\n\nfunction transformDirectoryCallback(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  if (typeof src !== 'string') throw new Error('transformDirectory: unexpected source');\n  if (typeof dest !== 'string') throw new Error('transformDirectory: unexpected destination directory');\n  if (typeof type !== 'string') throw new Error('transformDirectory: unexpected type');\n\n  const cwd = options.cwd || process.cwd();\n  const config = options.confg ? options.confg : getTS.getTsconfig(path.resolve(cwd, 'tsconfig.json'));\n  const matcher = createMatcher(config);\n\n  options = { ...options, config };\n  const iterator = new Iterator(src);\n  iterator.forEach(\n    (entry, cb) => {\n      if (!entry.stats.isFile()) return cb();\n      if (!matcher(entry.fullPath)) return cb();\n      transformFile(entry.fullPath, path.dirname(path.join(dest, entry.path)), type, options, cb);\n    },\n    { callbacks: true, concurrency: options.concurrency || 1024 },\n    callback\n  );\n}\n\n/**\n * @param {string} src The source directory to traverse.\n * @param {string} dest The output directory to write files to.\n * @param {string} type The type of transform ('esm' or 'cjs').\n * @param {{sourceMaps: boolean}} options Options to pass to swc.\n * @param {(err?: Error) =>} [callback] Optional callback. Uses promise if callback not provided.\n * @returns {void | Promise<any>} Optional promise if callback not provided.\n */\nexport default function transformDirectory(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n\n  if (typeof callback === 'function') return transformDirectoryCallback(src, dest, type, options, callback);\n  return new Promise((resolve, reject) => {\n    transformDirectoryCallback(src, dest, type, options, function compileCallback(err, result) {\n      err ? reject(err) : resolve(result);\n    });\n  });\n}\n"],"names":["path","Iterator","getTS","createMatcher","transformFile","transformDirectoryCallback","src","dest","type","options","callback","Error","cwd","process","config","confg","getTsconfig","resolve","matcher","iterator","forEach","entry","cb","stats","isFile","fullPath","dirname","join","callbacks","concurrency","transformDirectory","Promise","reject","compileCallback","err","result"],"mappings":"AAAA,OAAOA,UAAU,OAAO;AACxB,OAAOC,cAAc,cAAc;AACnC,OAAOC,WAAW,sBAAsB;AAExC,OAAOC,mBAAmB,sBAAsB;AAChD,OAAOC,mBAAmB,sBAAsB;AAEhD,SAASC,2BAA2BC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IACpE,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU,CAAC;IACb;IACA,IAAI,OAAOH,QAAQ,UAAU,MAAM,IAAIK,MAAM;IAC7C,IAAI,OAAOJ,SAAS,UAAU,MAAM,IAAII,MAAM;IAC9C,IAAI,OAAOH,SAAS,UAAU,MAAM,IAAIG,MAAM;IAE9C,MAAMC,MAAMH,QAAQG,GAAG,IAAIC,QAAQD,GAAG;IACtC,MAAME,SAASL,QAAQM,KAAK,GAAGN,QAAQM,KAAK,GAAGb,MAAMc,WAAW,CAAChB,KAAKiB,OAAO,CAACL,KAAK;IACnF,MAAMM,UAAUf,cAAcW;IAE9BL,UAAU;QAAE,GAAGA,OAAO;QAAEK;IAAO;IAC/B,MAAMK,WAAW,IAAIlB,SAASK;IAC9Ba,SAASC,OAAO,CACd,CAACC,OAAOC;QACN,IAAI,CAACD,MAAME,KAAK,CAACC,MAAM,IAAI,OAAOF;QAClC,IAAI,CAACJ,QAAQG,MAAMI,QAAQ,GAAG,OAAOH;QACrClB,cAAciB,MAAMI,QAAQ,EAAEzB,KAAK0B,OAAO,CAAC1B,KAAK2B,IAAI,CAACpB,MAAMc,MAAMrB,IAAI,IAAIQ,MAAMC,SAASa;IAC1F,GACA;QAAEM,WAAW;QAAMC,aAAapB,QAAQoB,WAAW,IAAI;IAAK,GAC5DnB;AAEJ;AAEA;;;;;;;CAOC,GACD,eAAe,SAASoB,mBAAmBxB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IAC3E,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU;IACZ;IACAA,UAAUA,WAAW,CAAC;IAEtB,IAAI,OAAOC,aAAa,YAAY,OAAOL,2BAA2BC,KAAKC,MAAMC,MAAMC,SAASC;IAChG,OAAO,IAAIqB,QAAQ,CAACd,SAASe;QAC3B3B,2BAA2BC,KAAKC,MAAMC,MAAMC,SAAS,SAASwB,gBAAgBC,GAAG,EAAEC,MAAM;YACvFD,MAAMF,OAAOE,OAAOjB,QAAQkB;QAC9B;IACF;AACF"}