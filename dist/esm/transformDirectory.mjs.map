{"version":3,"sources":["transformDirectory.mjs"],"sourcesContent":["import path from 'path';\nimport Iterator from 'fs-iterator';\nimport getTS from 'get-tsconfig-compat';\n\nimport createMatcher from './createMatcher.mjs';\nimport transformFile from './transformFile.mjs';\n\nfunction transformDirectoryCallback(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n\n  if (typeof src !== 'string') throw new Error('transformDirectory: unexpected source');\n  if (typeof dest !== 'string') throw new Error('transformDirectory: unexpected destination directory');\n  if (typeof type !== 'string') throw new Error('transformDirectory: unexpected type');\n\n  const config = options.confg ? options.confg : getTS.getTsconfig(src);\n  const matcher = createMatcher(config);\n\n  options = { ...options, config };\n  const iterator = new Iterator(src);\n  iterator.forEach(\n    (entry, cb) => {\n      if (!entry.stats.isFile()) return cb();\n      if (!matcher(entry.fullPath)) return cb();\n      transformFile(entry.fullPath, path.dirname(path.join(dest, entry.path)), type, options, cb);\n    },\n    { callbacks: true, concurrency: options.concurrency || 1024 },\n    callback\n  );\n}\n\n/**\n * @param {string} src The source directory to traverse.\n * @param {string} dest The output directory to write files to.\n * @param {string} type The type of transform ('esm' or 'cjs').\n * @param {{sourceMaps: boolean}} options Options to pass to swc.\n * @param {(err?: Error) =>} [callback] Optional callback. Uses promise if callback not provided.\n * @returns {void | Promise<any>} Optional promise if callback not provided.\n */\nexport default function transformDirectory(src, dest, type, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  options = options || {};\n\n  if (typeof callback === 'function') return transformDirectoryCallback(src, dest, type, options, callback);\n  return new Promise((resolve, reject) => {\n    transformDirectoryCallback(src, dest, type, options, function compileCallback(err, result) {\n      err ? reject(err) : resolve(result);\n    });\n  });\n}\n"],"names":["path","Iterator","getTS","createMatcher","transformFile","transformDirectoryCallback","src","dest","type","options","callback","Error","config","confg","getTsconfig","matcher","iterator","forEach","entry","cb","stats","isFile","fullPath","dirname","join","callbacks","concurrency","transformDirectory","Promise","resolve","reject","compileCallback","err","result"],"mappings":"AAAA,OAAOA,UAAU,OAAO;AACxB,OAAOC,cAAc,cAAc;AACnC,OAAOC,WAAW,sBAAsB;AAExC,OAAOC,mBAAmB,sBAAsB;AAChD,OAAOC,mBAAmB,sBAAsB;AAEhD,SAASC,2BAA2BC,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IACpE,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU,CAAC;IACb;IACAA,UAAUA,WAAW,CAAC;IAEtB,IAAI,OAAOH,QAAQ,UAAU,MAAM,IAAIK,MAAM;IAC7C,IAAI,OAAOJ,SAAS,UAAU,MAAM,IAAII,MAAM;IAC9C,IAAI,OAAOH,SAAS,UAAU,MAAM,IAAIG,MAAM;IAE9C,MAAMC,SAASH,QAAQI,KAAK,GAAGJ,QAAQI,KAAK,GAAGX,MAAMY,WAAW,CAACR;IACjE,MAAMS,UAAUZ,cAAcS;IAE9BH,UAAU;QAAE,GAAGA,OAAO;QAAEG;IAAO;IAC/B,MAAMI,WAAW,IAAIf,SAASK;IAC9BU,SAASC,OAAO,CACd,CAACC,OAAOC;QACN,IAAI,CAACD,MAAME,KAAK,CAACC,MAAM,IAAI,OAAOF;QAClC,IAAI,CAACJ,QAAQG,MAAMI,QAAQ,GAAG,OAAOH;QACrCf,cAAcc,MAAMI,QAAQ,EAAEtB,KAAKuB,OAAO,CAACvB,KAAKwB,IAAI,CAACjB,MAAMW,MAAMlB,IAAI,IAAIQ,MAAMC,SAASU;IAC1F,GACA;QAAEM,WAAW;QAAMC,aAAajB,QAAQiB,WAAW,IAAI;IAAK,GAC5DhB;AAEJ;AAEA;;;;;;;CAOC,GACD,eAAe,SAASiB,mBAAmBrB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,QAAQ;IAC3E,IAAI,OAAOD,YAAY,YAAY;QACjCC,WAAWD;QACXA,UAAU;IACZ;IACAA,UAAUA,WAAW,CAAC;IAEtB,IAAI,OAAOC,aAAa,YAAY,OAAOL,2BAA2BC,KAAKC,MAAMC,MAAMC,SAASC;IAChG,OAAO,IAAIkB,QAAQ,CAACC,SAASC;QAC3BzB,2BAA2BC,KAAKC,MAAMC,MAAMC,SAAS,SAASsB,gBAAgBC,GAAG,EAAEC,MAAM;YACvFD,MAAMF,OAAOE,OAAOH,QAAQI;QAC9B;IACF;AACF"}